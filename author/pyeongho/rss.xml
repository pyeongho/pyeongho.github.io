<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>pyeongho.github.io</title>
   
   <link>https://pyeongho.github.io</link>
   <description>즐거운 공장</description>
   <language>en-uk</language>
   <managingEditor> PyeongHo</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>round rect 마스크</title>
	  <link>//round_rect_mask</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-10-17T00:00:00+00:00</pubDate>
	  <guid>//round_rect_mask</guid>
	  <description><![CDATA[
	     <h3>안쪽이 둥근 모서리</h3>

<ul>
<li>둥근 모서리로 특정 뷰를 보여 줘야 할때</li>
<li>안쪽에 차트나 이미지가 있고 외부에서 마스킹 할때?!</li>
<li>편한 방법은 나인패치로 작업 하셔도 됩니다.</li>
<li>아래 리소스 처럼 하면 가운데가 뻥 뚫린 레이어를 만들 수 있습니다.</li>
<li>색상은 이해되기 쉽게 빨간색과 검정색을 사용 했습니다.</li>
<li>색상을 같은 색으로 하면 마스킹은 가능 합니다.</li>
</ul>
<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;layer-list</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;item</span>
        <span class="na">android:bottom=</span><span class="s">"-20dp"</span>
        <span class="na">android:left=</span><span class="s">"-20dp"</span>
        <span class="na">android:right=</span><span class="s">"-20dp"</span>
        <span class="na">android:top=</span><span class="s">"-20dp"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;shape</span> <span class="na">android:shape=</span><span class="s">"rectangle"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;stroke</span>
                <span class="na">android:width=</span><span class="s">"37dp"</span>
                <span class="na">android:color=</span><span class="s">"#ff0000"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;corners</span> <span class="na">android:radius=</span><span class="s">"10dp"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/shape&gt;</span>
    <span class="nt">&lt;/item&gt;</span>


    <span class="nt">&lt;item</span> <span class="na">android:bottom=</span><span class="s">"6dp"</span>
        <span class="na">android:left=</span><span class="s">"6dp"</span>
        <span class="na">android:right=</span><span class="s">"6dp"</span>
        <span class="na">android:top=</span><span class="s">"6dp"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;shape</span> <span class="na">android:shape=</span><span class="s">"rectangle"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;stroke</span>
                <span class="na">android:width=</span><span class="s">"12dp"</span>
                <span class="na">android:color=</span><span class="s">"#000000"</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;corners</span> <span class="na">android:radius=</span><span class="s">"10dp"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/shape&gt;</span>
    <span class="nt">&lt;/item&gt;</span>

<span class="nt">&lt;/layer-list&gt;</span>

</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>fragmentTransaction 사용 관련</title>
	  <link>//commit</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-10-10T00:00:00+00:00</pubDate>
	  <guid>//commit</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li><a href="https://pluu.github.io/blog/android/2017/01/26/fragmentTransaction/">https://pluu.github.io/blog/android/2017/01/26/fragmentTransaction/</a></li>
<li><a href="https://m.blog.naver.com/PostView.nhn?blogId=zoomen1004&amp;logNo=220198317501&amp;targetKeyword=&amp;targetRecommendationCode=1&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F">commit vs commitAllowingStateLoss</a></li>
</ul>

<h3>commit vs commitAllowingStateLoss</h3>

<ul>
<li>Fragment 실행은 commit 호출 이후, 하지만 commit는 ListCycle상 onSaveInstanceState()가 호출 되기 전에 수행되어야함 , 이를 어길 시 에러 발생 </li>
<li>onSaveInstanceState 이후 수행가능한 상황에서만 commit 사용</li>
<li>onSaveInstanceState 무관하게 동작 시키기 위해서는 commitAllowingStateLoss 를 사용하자</li>
<li>에러 발생이 무섭다면 commitAllowingStateLoss 사용을 추천 </li>
<li>에러 : java.lang.IllegalStateException:  Can not perform this action after onSaveInstanceState</li>
</ul>

<h3>commit vs commitNow</h3>

<ul>
<li>commitNow()라는 메소드 이름 그대로이지만 동기적으로 트랜잭션 처리를 해주는 것 같습니다. </li>
<li>자세한 내용은 참고 사이트에서 확인 가능합니다.</li>
<li>요약은 조금더 편리 commitNow()</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>R8 NullPointerException</title>
	  <link>//r8_error</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-07-23T00:00:00+00:00</pubDate>
	  <guid>//r8_error</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li><a href="https://github.com/square/okhttp/issues/4604">https://github.com/square/okhttp/issues/4604</a></li>
</ul>

<h3>그래들 수정후 성공</h3>

<ul>
<li>okhttp 와 문제가 발생하는걸로 보입니다.</li>
<li>아래와 같은 내용을 그래들에 추가 하여 해결하였습니다.</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang=""> buildscript {
     ...
     repositories {
         ...
         maven {
             url 'http://storage.googleapis.com/r8-releases/raw'
         }
     }

     dependencies {
         classpath 'com.android.tools:r8:1.5.50'  // Must be before the Gradle Plugin for Android.
         classpath 'com.android.tools.build:gradle:3.3.1'  // You don't need to upgrade this to use a newer R8 version.
         ...
      }
 }


</code></pre></div>
<h3>에러 내용</h3>
<div class="highlight"><pre><code class="language-" data-lang="">org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:transformClassesAndResourcesWithR8ForDebug'.
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:103)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)
    at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)
    at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)
    at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)
    at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)
    at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
    at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)
    at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)
    at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)
    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
    at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
    at com.android.tools.r8.shaking.Enqueuer.transitionDefaultMethodsForInstantiatedClass(Enqueuer.java:744)
    at com.android.tools.r8.shaking.Enqueuer.transitionDefaultMethodsForInstantiatedClass(Enqueuer.java:745)
    at com.android.tools.r8.shaking.Enqueuer.transitionMethodsForInstantiatedClass(Enqueuer.java:730)
    at com.android.tools.r8.shaking.Enqueuer.processNewlyInstantiatedClass(Enqueuer.java:674)
    at com.android.tools.r8.shaking.Enqueuer.trace(Enqueuer.java:1091)
    at com.android.tools.r8.shaking.Enqueuer.traceApplication(Enqueuer.java:1074)
    at com.android.tools.r8.R8.run(R8.java:286)
    at com.android.tools.r8.R8.run(R8.java:228)
    at com.android.tools.r8.R8.lambda$run$0(R8.java:133)
    at com.android.tools.r8.utils.ExceptionUtils.withCompilationHandler(ExceptionUtils.java:55)
    at com.android.tools.r8.utils.ExceptionUtils.withR8CompilationHandler(ExceptionUtils.java:48)
    at com.android.tools.r8.R8.run(R8.java:129)
    at com.android.builder.dexing.R8Tool.runR8(r8Tool.kt:145)
    at com.android.build.gradle.internal.transforms.R8Transform.transform(R8Transform.kt:202)
    at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:239)
    at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:235)
    at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:102)
    at com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:230)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)
    at org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)
    at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)
    at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)
    at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)
    ... 33 more


</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>redux 공부 중</title>
	  <link>//redux_study</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-07-12T00:00:00+00:00</pubDate>
	  <guid>//redux_study</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li>참고 글이 원본 입니다. </li>
<li><a href="https://qiita.com/Urotea/items/8cbc8f55406b6ff32bbd">샘플 공부</a></li>
<li><a href="https://github.com/Urotea/AndroidBoilerplate">샘플 코드</a></li>
<li><a href="https://github.com/freeletics/RxRedux">참고라이브러리</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>redux</title>
	  <link>//redux</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-07-09T00:00:00+00:00</pubDate>
	  <guid>//redux</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li>참고 글이 원본 입니다. </li>
<li><a href="https://voidsatisfaction.github.io/2017/02/24/what-is-redux/">리덕스(Redux)란 무엇인가?</a></li>
</ul>

<h3>리덕스</h3>

<ul>
<li>안드로이드용 공식 리덕스는 아니지만 리덕스의 기본적인 개념을 알고 일ㄹ</li>
<li><p>리덕스는 어플리케이션의 클라이언트쪽 state를 관리하기 위한 거대한 이벤트 루프이다.</p>

<ul>
<li>액션 = 이벤트</li>
<li>리듀서 = 이벤트에 대한 반응</li>
</ul></li>
<li><p>Redux의 동기</p>

<ul>
<li>Redux공식 문서(참조)에 의하면 리덕스는 클라이언트 앱의 복잡성을 제어하기 위한 하나의 state제어 수단이라고 한다(정확히는 방법론이 맞는것 같다.)</li>
<li>Redux를 제안하고 개발한 Dan Abramov는 클라이언트앱의 복잡성을 증가시키는게 Mutation과 Asynchronicity라며 그 둘을 멘토스와 콜라와 같다고 한다.</li>
<li>Mutation과 Asynchronicity는 각각 존재할때에는 대단한 것임에 틀림없지만 같이 존재할때 크나큰 복잡성을 유도한다는 것이다.</li>
<li>여기서 Redux는 Mutation, 즉 클라이언트의 종합적인 State를 관리하기 위한 아키텍쳐 방법론인 것이다. </li>
</ul></li>
<li><p>Redux의 원리</p>

<ul>
<li>어플리케이션 전체에는 store라는 커다란 하나의 state가 존재하는데 이것이 어플리케이션의 state를 총괄한다.</li>
<li>store의 state는 그 자체를 직접 변형할 수 없고, 오직 순수 함수인 리듀서로만 새로운 형태로 갈아치우는 것이 가능하다.</li>
<li>리듀서는 type과 payloads(꼭 속성이름이 이렇지 않아도 됨)를 속성으로 갖는 단순 객체인 action이벤트가 발생했을 때에만 작동하며</li>
<li>action이벤트를 발생시키는 방법은 dispatch라는 함수에 단순 객체인 action을 넣는것으로 가능하게 한다.</li>
<li>dispatch(action) =&gt; 리듀서 작동 =&gt; store의 state변경 =&gt; 변경된 state가 state를 subscribe하고 있는 컴포넌트에 전달</li>
</ul></li>
<li><p>Redux의 장점</p>

<ul>
<li>application state의 변화가 예측가능하게 변한다는 점이다</li>
<li>이는 특정 액션이벤트 발생에만 reducer가 작동하게 했기때문에 store state가 변한경우 그것이 정확히 어떠한 액션 이벤트로 부터변경된 것인지 알 수 있다.</li>
<li>정확히 어떤 액션 이벤트로 부터 변경된 것인지 알기 때문에 Time travel debugging이 가능해진다. 간단하게 얘기하자면 이제까지 store state가 변화해온 과정을 마치 뒤로가기 버튼이 있는것 처럼 하나하나 확인해볼 수 있는 것이다.</li>
<li>리듀서가 순수 함수(외부에 영향을 끼치지 않는 함수. ex: api calling이 없는 함수)이기 때문에 test코드를 짤 수 있다는 장점도 존재한다.</li>
<li>선언적으로 프로그래밍을 할 수 있다는 점이다(Declarative Programming)</li>
</ul></li>
<li><p>Redux와 Middleware</p>

<ul>
<li>action이 단순 객체이기 때문에 다음과 같은 행동이 불가능하다

<ol>
<li>로그인 요청을 보내며 로딩중이라는 표시를 뜨게 하기</li>
<li>회원가입 요청을 보내는데에 만약 이미 있는 id라면 에러 메세지를 보내고 아니라면 성공시킨다.</li>
</ol></li>
<li>action이 단순 객체라는 얘기는 조건 분기나 다른 action 이벤트를 생성할 수 없기 떄문에 우리는 action creator라는 action을 생성하는 함수를 생성한다. </li>
<li>action creator는 함수이기 때문에 Promise나 Callback을 적절히 조화하는 것으로 다른 action 이벤트를 생성할 수 있고, 조건 분기도 가능해진다. 사실 이름만 action creator이지 action자체를 반환하지 않아도 된다.</li>
<li>redux thunk는 함수를 반환하는 함수인데 dispatch를 가지고 함수를 warpping하고 있으므로 일일이 dispatch를 불러와야하는 귀찮음이 경감된다.</li>
</ul></li>
</ul>

<h4>리덕스의 정체</h4>

<ul>
<li>redux는 state관리를 위한 거대한 event loop

<ul>
<li>액션 = 이벤트</li>
<li>리듀서 = 이벤트에 대한 반응</li>
</ul></li>
<li>액션이벤트를 발생시켜서 리듀서라는 이벤트에 대한 반응을 일으키므로서 어플리케이션의 state를 a라는 상태에서 b라는 상태로 만든다.(a is b)<br></li>
<li><p>실제로 Dan Abramov는 공식 tutorial문서에서 이렇게 얘기하고 있다.</p>
<div class="highlight"><pre><code class="language-" data-lang="">    Following in the steps of Flux, CQRS, and Event Sourcing, Redux attempts to make state mutations predictable by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the three principles of Redux.
</code></pre></div></li>
<li><p>이벤트 기반의 프로그래밍론이 redux에 사상적으로 들어가 있는 것이다.     </p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>SOLID 를 공부해 보자</title>
	  <link>//oop-solid</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-06-25T00:00:00+00:00</pubDate>
	  <guid>//oop-solid</guid>
	  <description><![CDATA[
	     <h3>SOLID</h3>

<ul>
<li><p>침착하게 습습 후후 </p></li>
<li><p><a href="https://gmlwjd9405.github.io/2018/07/05/oop-solid.html">참고</a></p></li>
<li><p>OOP(객체지향 프로그래밍) 설계 원칙 ‘SOLID’를 이해한다.</p>

<ul>
<li>S: 단일 책임 원칙(SRP)를 이해할 수 있다. </li>
<li>O: 개방-폐쇄 원칙(OCP)을 이해할 수 있다.</li>
<li>L: 리스코프 치환 원칙(LSP)을 이해할 수 있다.</li>
<li>I: 인터페이스 분리 원칙(ISP)을 이해할 수 있다.</li>
<li>D: 의존 역전 원칙(DIP)을 이해할 수 있다.</li>
</ul></li>
<li><p>단일 책임 원칙(SRP, Single Responsibility Principle)</p>

<ul>
<li>객체는 단 하나의 책임만 가져야 한다.</li>
</ul></li>
<li><p>개방-폐쇄의 원칙(OCP, Open Closed Principle)</p>

<ul>
<li>기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.</li>
<li>클래스를 변경하지 않고도 대상 클래스의 환경을 변경할 수 있는 설계가 되어야 한다.</li>
</ul></li>
<li><p>리스코프 치환 원칙(LSP, Liskov Substitution Principle)</p>

<ul>
<li>일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</li>
<li>LSP는 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 한다는 의미다. 즉, LSP를 만족하면 프로그램에서 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변화되지 않는다.</li>
<li>일반화 관계

<ul>
<li>“is a kind of” 의 관계</li>
<li>예를 들어, 원숭이 is a kind of 포유류</li>
<li>포유류(부모 클래스), 원숭이(자식 클래스)</li>
</ul></li>
<li>LSP를 만족시키는 간단한 방법은 재정의하지 않는 것이다. 즉, 부모 클래스에서 상속받은 메서드들이 자식 클래스에 오버라이드, 즉 재정의되지 않도록 하면 된다.</li>
</ul></li>
<li><p>인터페이스 분리 원칙(ISP, Interface Segregation Principle)</p>

<ul>
<li>인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.</li>
<li>클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다.</li>
</ul></li>
<li><p>의존 역전 원칙(DIP, Dependency Inversion Principle)</p>

<ul>
<li>의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것.</li>
</ul></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>안드로이드 태생</title>
	  <link>//basic</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-06-12T00:00:00+00:00</pubDate>
	  <guid>//basic</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li>참고 글이 원본 입니다. </li>
<li>공부하기 위해서 재 작성한 내용입니다. 원본을 확인해 주세요.</li>
<li><a href="http://blog.naver.com/huewu/110085391353">안드로이드의 멀티태스킹 (Multitasking the Android Way)</a></li>
</ul>

<h3>메모리는 부족하지만 모든 어플리케이션은 항상 실행 중 인것처럼</h3>

<ul>
<li>우리는 사용자에게 특정 어플리케이션 사용을 끝마쳤을 때, 명시적으로 어플리케이션을 종료하지 않아도 되기를 원했다. 사용자들은 다양한 종류의 어플리케이션을 아주 짧게 그리고 반복적으로 사용하기 때문이다.</li>
<li>휴대용 장치들은 풍족한 스왑 메모리 공간을 갖고 있지 못하며, 메모리 사용에 빡빡한 제한을 갖고 있다. (첨:아주 짧게 여러개를 사용하면 부족해 질 수 있다.)</li>
<li>모바일 디바이스에서 어플리케이션 스위칭은 중요하다. 우리는 새로운 어플리케이션이 1초 이내에 시작될 수 있도록 굉장한 노력을 기울였다. 비디오를 보다가 새로 도착한 SMS 문자를 확인하고 다시 비디오 플레이 어플리케이션으로 돌아가는 등의 사용자 시나리오를 생각해 본다면, 몇몇 어플리케이션간의 빠른 스위칭은 특히 더 중요한 문제이다.</li>
<li>사용할 수 있는 API 는 안드로이드에 기본 내장된 구글 어플리케이션을 만들 수 있을 만큼 충분히 강력해야 한다. 이것은 우리의 &#39;모든 어플리케이션은 동등하다,&#39; 라는 철학의 문제이다. 즉, 백그라운드 음악 재생, 데이타 동기화, GPS 네비게이션, 어플리케이션 다운로드등의 기능은 서드 파티 어플리케이션 개발자들이 사용가능한 API 와 동일한 API 를 이용해서 작성되어야 한다. </li>
</ul>

<h3>안드로이드에서 프로세스 와 어플리케이션</h3>

<ul>
<li>안드로이드에서 프로세스와 어플리케이션은 밀접하게 연결(tightly coupled)되어 있는 요소가 아니며, 어플리케이션은 해당 어플리케이션을 작동시키고 있는 프로세스가 없음에도 사용자에게 현재 작동하고 있는 것 처럼 보일 수도 있고, 또, 여러 어플리케이션이 프로세스를 공유 할 수도 있습니다. 혹은 필요에 따라 하나의 어플리케이션이 여러개의 프로세스를 사용할 수도 있고, 실재로 어플리케이션이 작동 중이 아님에도, 어플리케이션을 구동했던 프로세스들은 종료되지 않고 안드로이드 시스템에 의해 유지될 수 있습니다.</li>
<li>어플리케이션의 프로세스는 단순히 안드로이드 시스템이 해당 프로세스가 필요 했었고, 이 후에 해당 프로세스가 다시 사용될 경우에 대비해서 프로세스를 유지하기로 결정했기 때문에 살아있는 것 뿐입니다.</li>
<li>안드로이드가 어플리케이션을 관리하는 핵심은 프로세스를 깔끔하게 종료시키지 않는 것입니다.</li>
</ul>

<h3>Explicitly running in the background : 명시적으로 백그라운드 작업</h3>

<ul>
<li>어플리케이션은 안드로이드 시스템에게 명시적으로 백그라운드 상에서 작업이 수행되어야 함을 알릴 필요가 있습니다. 어플리케이션은 메니페스트 상에 &#39;Broadcast Receiver&#39; 혹은 &#39;Service&#39; 요소를 선언할 수 있으며, 이 두가지 요소를 통해 명시적으로 백그라운드 작업을 수행 할 수 있습니다.</li>
<li>Broadcast Receiver

<ul>
<li> Broadcast Receiver 는 어플리케이션이 특정한 이벤트가 발생하는 경우에, 아주 짧은 시간동안 백그라운드에서 작업 가능</li>
</ul></li>
<li>Service

<ul>
<li>어플리케이션이 안드로이드 시스템에게 &quot;헤이~ 나는 내가 종료되었다고 하기 전까지 백그라운드에서 계속해서 작동했으면 좋겠어!&quot; 라고 알려주는 것입니다. 어플리케이션은 명시적으로 Service 를 시작 하거나 종료 시킬 수 있습니다.</li>
<li>메모리가 부족해 진다면, Service 가 작동중인 프로세스 또한 강제로 종료</li>
<li>Service 는 안드로이드 시스템에 미리 자신을 &#39;Foreground&#39; 상태로 간주해 달라고 이야기할 수도 있습니다. 이것은, &quot;나를 죽이지 마세요&quot; 라는 뜻인데, 이 경우 해당 Service 는 사용자에게 자신이 현재 작동중임을 Notification (안드로이드 화면 상단의 상태바) 을 통해 표시해 주어야 합니다</li>
</ul></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>안드로이드 context</title>
	  <link>//context</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-05-24T00:00:00+00:00</pubDate>
	  <guid>//context</guid>
	  <description><![CDATA[
	     <h3>참고</h3>

<ul>
<li>참고 글이 원본 입니다. </li>
<li>공부하기 위해서 재 작성한 내용입니다. 원본을 확인해 주세요.</li>
<li><a href="https://arabiannight.tistory.com/entry/272">안드로이드/Android Context 란?</a></li>
</ul>

<h3>Context</h3>

<ul>
<li> <a href="https://developer.android.com/reference/kotlin/android/content/Context.html">안드로이드 개발자사이트 Context</a></li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">    Interface to global information about an application environment. 
    This is an abstract class whose implementation is provided by the Android system.
    It allows access to application-specific resources and classes, 
    as well as up-calls for application-level operations such as launching activities, 
    broadcasting and receiving intents, etc.

    어플리케이션 환경에 관한 글로벌 정보에 접근하기위한 인터페이스. Abstract 클래스이며 실재 구현은  
    안드로이드 시스템에 의해 제공된다. Context를 통해, 어플리케이션에 특화된 리소스나 클래스에 접근할 수 있을뿐 아니라,
    추가적으로 어플리케이션 레벨의 작업. activity 실행, intent 브로드캐스트, intent 수신 등을 한다. 
</code></pre></div>
<ul>
<li><p>Context 는 크게 두 가지 역할을 수행하는 Abstract 클래스 입니다.</p>

<ul>
<li>어플리케이션에 관하여 시스템이 관리하고 있는 정보에 접근하기(getPackageName() 등)<br></li>
<li>안드로이드 시스템 서비에서 제공하는 API 호출 (startActivity() 등)</li>
</ul></li>
<li><p>Context 는 어플리케이션과 관련된 정보에 접근하고자 하거나 어플리케이션과 연관된 시스템 레벨의 함수를 호출하고자 할 때 사용됩니다. 그런데 안드로이드 시스템에서 어플리케이션 정보를 관리하고 있는 것은 시스템이 아닌, ActivityManagerService 라는 일종의 또 다른 어플리케이션입니다. 따라서 다른 일반적은 플랫폼과는 달리, 안드로이드에서는 어플리케이션과 관련된 정보에 접근하고자 할때는 ActivityManagerService 를 통해야만 합니다. 당연히 정보를 얻고자 하는 어플리케이션이 어떤 어플리케이션인지에 관한 키 값도 필요해집니다.</p></li>
<li><p>Context 역할</p>

<ul>
<li>자신이 어떤 어플리케이션을 나타내고 있는지 알려주는 ID 역할</li>
<li>ActivityManagerService 에 접근할 수 있도록 하는 통로 역할 </li>
</ul></li>
<li><p>Context 를 가지고 다른 시스템 애플리케이션들에게 명령하거나 값을 가지고 온다. </p></li>
</ul>

<h3>참고</h3>

<ul>
<li><a href="https://arabiannight.tistory.com/entry/272">안드로이드/Android Context 란?</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>안드로이드 스튜디오 로그에 링크 추가하기</title>
	  <link>//log_link</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-04-12T00:00:00+00:00</pubDate>
	  <guid>//log_link</guid>
	  <description><![CDATA[
	     <h3>안드로이드 개발중에 로그를 출력하면서 불편한 점 개선 하기</h3>

<ul>
<li>로그출력 기능의 추가</li>
<li>로그 출력시 파일명과 메소드 명으로 찾기 불편한 사람들을 위함 </li>
</ul>

<h2>안드로이드 개발중에 로그를 출력하면서 불편한 점 개선 하기</h2>

<ul>
<li>아래 코드와 비슷하게 만들어 로그를 사용하고 있습니다. </li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">  new Exception().getStackTrace()[0]
</code></pre></div>
<ul>
<li>getFileName(), getLineNumber(), getMethodName() 등을 Log.d 에 출력 해서 사용하고 있습니다.</li>
<li><p>기존에 작성 했던 내용을 업데이트 할 예정 입니다. 
<script src="https://gist.github.com/pyeongho/9b3caab3a7173a6890f64117ff483a0b.js"></script></p></li>
<li><p>element  인텍스 값은 현재 함수, 호출 함수를 찾는 내용</p></li>
</ul>

<h2>안드로이드 스튜디오 로그 링크 추가 하기</h2>

<ul>
<li><p>간단하게 아래와 같은 내용으로 로그를 출력하면 마지막에 링크가 걸리는 내용이 있습니다.
<code>
Exception().getStackTrace()[0].toString()
</code></p></li>
<li><p>문제는 로그 내용이 너무 길어 화면 밖으로 출력되어 불편 </p></li>
<li><p>찍기 신공, 로그에 링크를 어떻게 줄까?</p></li>
<li><p>(파일이름:라인)</p></li>
<li><p>결론은 위와 같은 형태로 출력하면 링크가 걸린다. </p></li>
<li><p>최종 로그 클래서는 아래와 같습니다.</p></li>
<li><p>사용법은 log.l() , log.d(&quot;test&quot;) 등등을 이용 하면 링크걸린 내용과 함께 원하는 내용이 출력 </p></li>
</ul>

<p><script src="https://gist.github.com/pyeongho/9033b0d6201bd205214489cdcb4caf11.js"></script></p>

	  ]]></description>
	</item>

	<item>
	  <title>루팅 기기에서 원격 ADB</title>
	  <link>//root_adb</link>
	  <author>PyeongHo</author>
	  <pubDate>2019-04-11T00:00:00+00:00</pubDate>
	  <guid>//root_adb</guid>
	  <description><![CDATA[
	     <h3>루팅 기기에서 ADB 원격 가능하도록 하는 방법</h3>

<p><script src="https://gist.github.com/pyeongho/20bc05ab4648c13cf29d2fb7eff583ad.js"></script></p>

	  ]]></description>
	</item>


</channel>
</rss>
