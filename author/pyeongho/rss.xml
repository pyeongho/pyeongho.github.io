<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>pyeongho.github.io/</title>
   
   <link>https://pyeongho.github.io/</link>
   <description>즐거운 공장</description>
   <language>en-uk</language>
   <managingEditor> PyeongHo</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>스태틱으로 변경하기</title>
	  <link>//github-static</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-29T00:00:00+00:00</pubDate>
	  <guid>//github-static</guid>
	  <description><![CDATA[
	     <h4 id="section">테마를 변경하면서 스택으로 변경하기로 결정</h4>
<ul>
  <li>테마변경을 적용중 원하는 카테고리 동작이 안되어서 찾아보니 특정 폴더를 추가해야 하는걸 알았습니다. 그래서 이것 저것 찾다가 결국은 스태틱 사이트로 변경 하기로 결정</li>
  <li>목표 설정
    <ul>
      <li>저장소 위치를 비트버켓으로 이동한다.</li>
      <li>지킬로 빌드후 결과물을 pyeongho.github.io 로 올린다.</li>
    </ul>
  </li>
</ul>

<h4 id="section-1">1. 우선 저장소 옮기는 건 쉬움</h4>
<ul>
  <li>git remote add 태그 [저장소 위치]</li>
  <li>추가된 저장소로 푸시</li>
</ul>

<h4 id="section-2">2. 지킬 컴파일 환경 구성</h4>
<ul>
  <li>테마 변경중이라 글을 못섰지만</li>
  <li>sudo jekyll serve 를 하기위해서 이거저것 해서 성공</li>
</ul>

<h4 id="section-3">3. 기존 파일을 모두삭제</h4>
<ul>
  <li>스태틱 파일이 정상적으로 생기는걸 확인하고 해당 파일로 전체 파일 변경</li>
  <li>모두 정상 동작</li>
</ul>

<h4 id="section-4">4. 지금 쓰는건 테스트 하기위함</h4>
<ul>
  <li>수동으로 비트버켓에 푸시</li>
  <li>jekyll build</li>
  <li>결과물을 pyeongho.github.io 로 푸시</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>비트버켓에서 파이프라인을 이용한 자동 배포</title>
	  <link>//bitbucket-deploy</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-29T00:00:00+00:00</pubDate>
	  <guid>//bitbucket-deploy</guid>
	  <description><![CDATA[
	     <h4 id="section">자동배포시스템 적용하기</h4>
<ul>
  <li>github 를 이용할때는 travis 를 이용하려 햐였지만 비트버켓으로 이동하면서 최종적으로 비트버켓 내의 시스템을 이용함</li>
</ul>

<h4 id="section-1">1. 스태틱으로 변경 후 배포 방법 개선이 필요 하다고 생각</h4>
<ul>
  <li>블로그 업데이트 순서
    <ul>
      <li>비트버켓에서 클론</li>
      <li>글 작성</li>
      <li>비트버켓에 오리지널 마크다운 푸시</li>
      <li>로컬에서 지킬 빌드 후 결과를 깃허브에 푸시</li>
    </ul>
  </li>
  <li>위 같은 순서를 하려고 하니 너무 끔직함</li>
  <li>스크립트를 작성해서 하려 했지만 마크다운 툴을 비주얼스튜디오 코드를 사용하다 보니 스크립트 명령을 부를수가 없다.</li>
  <li>명령창을 열어서 스크립트 실행? 이것도 귀찮다.</li>
  <li>만약 로컬에서 지킬 빌드가 안되면 어떻게? 저거 하려면 몇 단계를 거쳐야 하는거야.. 나름 코딩하는 사람인데</li>
</ul>

<h4 id="section-2">2. 트래비스 삽질</h4>
<ul>
  <li>jekyll/jasper 테마가 트래비스 연동을 추천해서 해당 방법을 계속 찾음</li>
  <li>깃허브에서도 실패한 트래비스</li>
  <li>비트버켓에서 트래비스 가능 할거라 생각하고 찾아지만 한글이나 영어 둘다 자료가 너무 없음</li>
  <li>검색을 조금 바꿔보니 비트버켓은 자체 ci 를 제공하는걸로 보임</li>
  <li>파이프라인 이라는 용어찾음</li>
</ul>

<h4 id="section-3">3 비트버켓 파이프라인 적응기</h4>
<ul>
  <li>비트버켓 저장소의 설정을 확인하면 pipeline 설정 항목이 보인다.</li>
  <li>항목을 설정하면 파이프라인 설정 파일을 만들수있다.</li>
  <li>지킬을 루비라는것만 알아서 ..</li>
  <li>다시 검색을 시작</li>
  <li><a href="https://blog.nathanaelcherrier.com/2017/02/01/utiliser-jekyll-avec-bitbucket-pages/">https://blog.nathanaelcherrier.com/2017/02/01/utiliser-jekyll-avec-bitbucket-pages/</a></li>
  <li>위 링크에서 어떻게 해야 할지를 발견함</li>
  <li>내가 생각했던 순서를 정확하게 똑같이 하려는 분을 만남. 감사합니다.</li>
</ul>

<h4 id="section-4">4. 자동 배포 시스템</h4>
<ul>
  <li>파이프라인 얌 파일 설정</li>
  <li>
    <script src="https://gist.github.com/pyeongho/fe5b671a55f6c18d6f6f918af27cfbe7.js"></script>
  </li>
  <li>번들 빌드 하기위해서는 Gemfile Gemfile.lock 파일 필요합니다.(재스퍼 테마에서 파일 참고)</li>
  <li>위 내용중 SITE_A 는 비트버켓 설정에 가능합니다. 공개된곳에 암호를 입력할수 없기에 설정에서 환경 변수 등록이 가능합니다.
    <ul>
      <li>setting -&gt; Environment variables -&gt; 문자열 등록</li>
    </ul>
  </li>
  <li>처음에는 토큰을 트래비스가 했던 토큰 방법을 찾아 보았는데 계속 실패하고 설마 했는데 사이트에 환경변수 입력하는 곳 있어서 github push 조건을 만들었습니다.</li>
  <li>그래서 테스트 푸시를 했지만 컴파일 에러 에러 에러 ..</li>
  <li>처음에는 루비 버전 문제라 생각 하고 재스퍼의 트래비스와 동일한 버전으로 변경했지만 실패..</li>
  <li>에러 메시지를 자세히 읽어보니 json 1.8.3 라고 나와 있지만 정확히 안알려줌</li>
  <li>에러 메시지로 구글링 하니 동일한 증상에 대한 해결책이 있음</li>
  <li><a href="https://github.com/flori/json/issues/303">https://github.com/flori/json/issues/303</a></li>
  <li>여기에 보면 ruby 2.4 에서는 1.8.3 버전이 동작 안한다고 함</li>
  <li>그래서 Gemfile.lock 파일에서 json 1.8.3 을 2.0.2 로 변경 지킬 컴파일 완료</li>
  <li>자동 배포 완료</li>
  <li>비트버켓 파이프라인에서 진행상황 또는 결과들을 볼 수있습니다.</li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3REF4SGtfZEhpWVU" alt="결과" /></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>미라클 모닝,당신의 하루를 바꾸는 기적</title>
	  <link>//navi_morning</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-22T00:00:00+00:00</pubDate>
	  <guid>//navi_morning</guid>
	  <description><![CDATA[
	     <h4 id="section">본것 깨달은것 적용할것</h4>

<h4 id="section-1">1. 내꺼</h4>
<ul>
  <li>미라클 모닝
    <ul>
      <li>명상: 앉아서, 고요히, 평화롭게, 천천히, 깊히 호흡 하면서</li>
      <li>확신의 말:  나의 무한한 가능성과 우선 과제들을 상기시켜주는 다짐과 확신의 말을 큰소리로 읽기</li>
      <li>비전보드 : 눈을 감아 상상하거나, 비전보드를 보며 실제 처럼 생생하게 성과를 그려 본다.</li>
      <li>쓰기 : 감사함을 느끼는 대상, 자랑스러운 기억, 노력해서 얻어낸 결과를 일기장에 적는다.</li>
      <li>읽기 : 자기계발서를 읽는다.</li>
      <li>운동 : 일어서서 몸을 움직인다.</li>
    </ul>
  </li>
  <li>36: 성공과 정도가 자기계발의 정도를 넘어서는 경우는 드물다. “ 성공과 일치되는 노력”</li>
  <li>60: 평범
    <ul>
      <li>룸미러 증후군 : 자신은 안된다. 한계를 설정해서 자신을 미리 규정한다.</li>
      <li>목표의식 결여
        <ul>
          <li>목표의식 만들기 :사소하고 간단한 목표, 언제나 바꿔도 되는 목표, 목표에 맞춰 살자</li>
        </ul>
      </li>
      <li>사건의 분리: 약속깨는것 정도는 괜찬다.</li>
      <li>책임감 부족</li>
      <li>평범한 영향력 집단에 있기, 밝은사람 주변에는 밝은 사람만</li>
      <li>낮은 자기계발 정도</li>
      <li>절박함의 부족</li>
    </ul>
  </li>
  <li>“목표는 결정 하는것이다”</li>
  <li>85: 아침 일찍 일어나기 위해서는 휴가 첫날의 설렘을 가져보자</li>
  <li>121: 목표는 구체적으로
    <ul>
      <li>‘나는 일주일에 5일 헬스클럼에 갈것이다. 최소 20분간 러닝머신을 뛸 것이다. 20분동안 온전히 뜀박질에 집중 할 것이다’</li>
      <li>빈도, 양, 정확한 시간으로 목표를 정한다.</li>
    </ul>
  </li>
  <li>126: 꿈을 시각화 해보자
    <ul>
      <li>예) 난 어디에 취직해서 어떤 개발자가 되어서 어떤 코딩을 할것이다.</li>
    </ul>
  </li>
  <li>147:  생각을 손으로 정리하면 조금더 명확해 진다.</li>
  <li>158: 침묵(명상)5분 -&gt; 확신의말 5분 -&gt; 시각화 5분 -&gt; 운동 20분 -&gt; 독서 20분 -&gt; 일기쓰기 5분</li>
</ul>

<h4 id="section-2">2. 타인의 생각</h4>
<ul>
  <li>A : ‘오늘을 마지노선으로 그어라’ 에 대한 의문점이 많다.</li>
  <li>B
    <ul>
      <li>교육의 질이 교사를 넘어서기 힘들다.</li>
      <li>8번 노출의 힘</li>
      <li>아프리카에 우물 파기, 하루 4시간씩 물을 구하러 이동하지만 우물을 파기위한 시간이 없다. 우선순위를 정하자</li>
      <li>우리가 가진 빛은 다른 사람에게 전파 된다.</li>
    </ul>
  </li>
  <li>C : 나를 사랑 하자, 나를 비난하지 말자</li>
  <li>D
    <ul>
      <li>평범함에 안주 하지 않겠다.</li>
      <li>확신을 무한히 외친다.</li>
      <li>숨쉬는걸 느껴 보자</li>
    </ul>
  </li>
  <li>E : 다른사람에게 좋은 인상을 주려고 노력하지 말고 자신을 보여주자, (목표설정), (멘토), (동료), (의지)</li>
  <li>F : 마음만 먹고 행동하지 않는건 기록하지 않아서 이다.</li>
  <li>G : 환경 &lt;- 행동 &lt;- 능력 &lt;- 믿음 &lt;- 정체성
    <ul>
      <li>금수저 흙수저는 행동으로 해결한다.</li>
      <li>습관이 중요하다.</li>
    </ul>
  </li>
</ul>

<h4 id="section-3">3. 책 추천</h4>
<ul>
  <li>‘새벽나라에 사는 거인’</li>
  <li>‘내 영혼을 담은 인생의 사계절: 짐론’</li>
</ul>

<h4 id="section-4">다시 한번</h4>
<ul>
  <li>목표는 결정 하는것이다.</li>
  <li>8번 노출의 힘</li>
  <li>자신의 목표 꿈을 무한 반복하자</li>
</ul>

<h4 id="section-5">현장 메모 첨부</h4>
<ul>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3TUxaNGV6LU15M1U" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3Uy1JSEV0TnNxVXc" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3YjBtaGRGcnBWTzg" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3UzdkaDQtbmtMRG8" alt="" /></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>구글에서 만든 클린 아키텍처를 이해하고 알아보자</title>
	  <link>//google-todo-clean</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-22T00:00:00+00:00</pubDate>
	  <guid>//google-todo-clean</guid>
	  <description><![CDATA[
	     <h3 id="section">구글 클린 아키텍처</h3>
<ul>
  <li>mvp 패턴만 적용 하더라도 구조가 이상해 보인다. 어떻게 하면 좀더 좋은 구조를 만들 수 있을까를 고민하던 중 클린아키텍처가 있었고 그중 구글이 만들 샘플 코드가 기본 라이브러리로만 만들어져서 마음에 들어서 분석하기 시작함</li>
</ul>

<h4 id="section-1">1. 구글 샘플 분석 하기</h4>
<ul>
  <li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/">https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/</a></li>
  <li>패키지 구분을 어떻게 했는지 직관적인 확인이 어렵다.(아직 적응 못함)</li>
  <li>한눈에 Uncle Bob clean architecture 레이어 확인 가능 할 줄 알았다.</li>
  <li>처음 보이는건 테스트 유닛만 보인다.</li>
  <li>그래도 구글이니 잘 만들었을거라 예상하고 다시 확인 시작</li>
  <li>참고로 구글 프로젝트라서 그런지 구아바를 사용 중
    <ul>
      <li><a href="https://github.com/google/guava">https://github.com/google/guava</a></li>
      <li>구글의 자바 라이브러리라고 생각하면 좋음</li>
      <li><a href="https://blog.outsider.ne.kr/710">구아바를 사용해야 하는 5가지 이유</a></li>
      <li><a href="http://heowc.tistory.com/61">구아바 맛보기</a></li>
    </ul>
  </li>
  <li>todo 앱 으로 할일을 만들고 체크해서 할일 완료 할일을 확인하는 앱이다.</li>
  <li>가장 기본이 되는 엔티티 레이어를 찾아보자</li>
  <li>패키지 이름에 없어서 구조를 확인해서</li>
  <li>아래와 같은 구조로 설계되어 있다</li>
  <li>패키지 이름에서 데이터 소스코드가 보임</li>
  <li>com.example.android.architecture.blueprints.todoapp.data.source</li>
  <li>감사하게 아래처럼 패키지 이름이 정의 되어 있습니다.</li>
  <li>설계와 동일하게 로컬과 리모트 패키지도 보이고</li>
  <li>엔티티 개념을 보이는 내용이 없다.</li>
  <li>클린아키텍처를 이해하기로 앱을 본질은 투두를 만들려고 했으니 기본적인 할일의 제목 할일의 설명 했다, 안했다. 에 대한 클래스가 있을거라 예상 했지만 해당 패키지에는 없다.</li>
  <li>위 데이터레이어 패키지를 확인해보니 Task 라는 클래스가 보인다.</li>
  <li>패키지는 com.example.android.architecture.blueprints.todoapp.tasks.domain.model;</li>
  <li>글을 좀더 자세히 읽어보니 MVP 모델의 중간에 도메인 레이어를 추가한 개념을 사용한걸로 보인다.
    <ul>
      <li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/">https://github.com/googlesamples/android-architecture/tree/todo-mvp/</a> 설명에 나와 있는데 안읽고 이제 서야 읽어봄</li>
      <li>위 샘플을 기반을 클린 아키텍처를 구현함</li>
      <li>Google todo mvp 를 살짝 보고 돌아옴</li>
    </ul>
  </li>
  <li>MVP 기반의 코드와 다른 점은 중간에 도메인 레이어를 추가 한 점입니다.</li>
  <li>데이터 &lt;- 도메인 &lt;- 프리젠터 레이어로 구성되어 있습니다.</li>
  <li>TasksDataSource(데이터레이어) &lt;- usecase(도메인레이어) &lt;- 프리젠테이션레이어(사용자)</li>
  <li>처음에는 별로 마음에 안들었지만 보다 보면 볼수록 마음에 듬</li>
  <li>정리중</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>크롬 40+ 버전에서 의 앱 실행 문제</title>
	  <link>//chrome-40</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-22T00:00:00+00:00</pubDate>
	  <guid>//chrome-40</guid>
	  <description><![CDATA[
	     <h3 id="section">크롬에서 사용자 제스처 없이 앱 실행은 안됩니다.</h3>
<ul>
  <li>탐색할수없음</li>
</ul>

<h4 id="javascript--body-onload-----">1. javascript 의 body onload 에 마켓 이동하는 코드를 추가</h4>
<ul>
  <li>아래와 같이 간단하게 추가 했는데 마켓으로 이동 안하는 기기들이 있음</li>
</ul>

<p>```javascript
   <script>
    function go_marget(){
         top.location.href = 'market://details?id=com.xxx.xxx';
    }
   </script></p>
<body onload="go_marget()">   

  ```

  - 크롬 인스펙트를 이용해서 콘솔로그를 확인하니 "탐색할수없음" 이라는 문구가 나옴

#### 2. 구글 검색 시작
  - 이것 저것 검색 하다 보니 chrome 40+ 이상에서는 동작 안하는다는 내용 확인 
  - [https://devtalk.kakao.com/t/onload/15293/2](https://devtalk.kakao.com/t/onload/15293/2)

  - 그래서 조금더 검색
  - [http://blog.tapstream.com/google-changes-chrome-to-prevent-abusive/](http://blog.tapstream.com/google-changes-chrome-to-prevent-abusive/)
  - 에서 내용을 잘 정리해줌 

#### 3. 내용 요약
  - 구글엔지니어가 판도라 앱을 설치
  - 주소창에 pandora.com 을 크롬에서 입력
  - 웹사이트로 이동되지 않고 판도앱이 실행됨
  - 버그로 접수 
  - 수정해 버림 

#### 4. 구글의 답변 
 - 원문 : From the omnibox, no, there is no plans to allow external redirects.  If typing in the omnibox, the user is showing a strong intent to stay within chrome, so we made the decision to not allow external redirects (too many of them led to what we believed to be bad user experiences).
Clicking on a link should still behave as before and redirect to market:// links. As it stands, how can I programmatically redirect a user to the play store?
There is no plans to support a redirect without a user gesture.

- 번역기 : 검색 주소창에서 외부로 리디렉션을 허용 할 계획이 없습니다. 검색 주소창에 검색어를 입력하면 사용자는 크롬 내에 머물러야한다는 강한 의지를 나타내고 있으므로 외부 리디렉션을 허용하지 않기로 결정했습니다. 너무 많은 사용자가 사용자 경험이 좋지 않다고 생각하는 것으로 이끌었습니다. 
링크를 클릭하면 이전과 같이 작동하고 market : // 링크로 리디렉션되어야합니다. 그대로, 어떻게 프로그래밍 방식으로 사용자를 플레이 스토어 로 리디렉션 할 수 있습니까? 
사용자 gestur e 없이 리디렉션을 지원할 계획은 없습니다 .

#### 5. 수정 사용자 제스처로 이동하게 하면 됩니다.
  - 사용자 액션안에서 처리하면 됩니다. 아래는 컨펌창으로 한 예제 입니다.
  - 사용자 액션만 추가 하면 됩니다.
  
  ```javascript
    <script>
      function go_marget(){
        if(confirm("앱을 실행 하시겠습니까?") == true){  
          top.location.href = "market://details?id=com.xxx.xxx";
        }else{   //취소
          return;
        }
      }
   </script>
   <body onload="go_marget()">   

  ```


</body></body>

	  ]]></description>
	</item>

	<item>
	  <title>GRIT IQ, 재능 환경을 뛰어 넘는 열정적 끈기의 힘 그릿</title>
	  <link>//navi_grit</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-15T00:00:00+00:00</pubDate>
	  <guid>//navi_grit</guid>
	  <description><![CDATA[
	     <h4 id="section">본것 깨달은것 적용할것</h4>

<h4 id="section-1">1. 내꺼</h4>
<ul>
  <li>43: “낙담했죠. 정말 실망했지만 그 일을 곱 씹고 있지는 않았어요. 다음에 어떡해야 할지 거기에 집중해야 한다고 생각했어여. 그래서 선생님을 찾아가서 도움을 청했어요”</li>
  <li>46: 사람들은 문제가 이해가 안되면 보통 ‘나중에 다시 생각해봐야겠다’고 한뒤에 사실상 잊어버린다.</li>
  <li>56: ‘엔론’ 하위 15%를 해고, 맥킨지의 전략중 하나, 성실성을 막는 근무 환경을 만드는데 일조</li>
  <li>94: 어떤 경기에서의 우승이나 시즌우승, 공격적 라인업 구성, 선수들과 대화하는 기술 등의 개별 목표들을 조직화하고 목적을 설정할 필요가 있을을 깨달았다. 그는 이렇게 말했다. “명확하게 서술된 철학은 궤도를 유지할 수 있는 지침과 범위를 제공한다.</li>
  <li>156: 전부 이해했는지는 중요하지 않아. 이야기를 들어주는게 중요하지</li>
  <li>169: 전문가들은 가능한 빨리 자신의 수행에 대한 피드백을 받고 싶어 한다. 물론 그 피드백에는 부정적인 내용이 많다. 그들은 자신이 잘한 부분보다 앞으로 고쳐나가야 할 틀린 부분에 더 관심이 많은 것이다. 핃백을 적극적으로 수용하는 자세는 즉각적인 피드백만큼이나 매우 중요하다.</li>
  <li>
    <p>168: 의식적인 연습을 하지 않기 때문에 발전이 없는거에요</p>
  </li>
  <li>생각
    <ul>
      <li>노력이 중요하다. 일반적인 노력이 아닌 의식적인 노력 목표가 있는 노력이 필요하다.</li>
      <li>성취 = 재능 * 노력 * 노력</li>
      <li>현재 잘 하는 사람(재능) , 천부적인 거라 방법이 없다.</li>
      <li>앞으로 잘 할 사람(노력) , 노력하면 된다는 희망을 줄 수 있다.</li>
    </ul>
  </li>
</ul>

<h4 id="section-2">2. 남의껏</h4>
<ul>
  <li>A (CEO)
    <ul>
      <li>열정은 지속성이다. 모래알을 쌓아서 모래성을 만드는 끈기와 같은 것이다.</li>
      <li>99: 워렌버핏의 최종 목표를 찾아 봐야 한다. 25개 -&gt; 5개 정말 원하는 최종 목표</li>
      <li>166: 1만시간의 법칙</li>
    </ul>
  </li>
  <li>B (CEO)
    <ul>
      <li>재능이 필요 하다.</li>
      <li>노력도 필요 하지만 재능이 있어야 한다.</li>
    </ul>
  </li>
  <li>C (군인,중령)
    <ul>
      <li>가장 똑똑한 사람은 못 되더라도 가장 집념이 강한 사람이 되려고 할것이다.</li>
      <li>재능, 잠재력만 가지고 있어서는 안되는 노력으로 잠재력을 발휘 시켜야 한다.</li>
      <li>96: 열정은 날마다 잠들 때까지 생각했던 질문을잠에서 깨어나는 순간부터 다시 생각하게 만든다.</li>
      <li>93: 현재의 수준을 뛰어 넘어라</li>
      <li>103: 상위목표는 잉크로 적고,하위목표는 수정하기 쉬운 연필로 적어라</li>
      <li>104: 여러번 시도해야하지만 다른 방법으로 시도해야 한다.</li>
    </ul>
  </li>
  <li>D
    <ul>
      <li>천직을 찾는건 중요하다.</li>
      <li>많은 시간 노력만으로는 지치게 쉽다.</li>
    </ul>
  </li>
  <li>E (전기전자 -&gt; 산업)
    <ul>
      <li>선천적 재능의 신화화는 자신을 안주 하게 만든다.</li>
      <li>재능을 핑계로 노력하지 않는 행동을 하지 말자</li>
    </ul>
  </li>
  <li>F
    <ul>
      <li>같은 일을 할때 목표가 있나
        <ul>
          <li>벽돌쌓기, 담쌓기, 성쌓기</li>
        </ul>
      </li>
      <li>자신이 늘 부족해 보였다. 그들은 현실에 안준하는 사람들과 정반대 였다.그럼에도 불만을 가지는 자신에겍 정말로 만족을 느겼다.</li>
      <li>부족한 부분 -&gt; 다음에는 수정 -&gt; 부족한 부분 -&gt; 다음에는 수정</li>
      <li>243: 그릿을 약화하는 표현 과 강화하는 표현</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>성장형 사고 방식과 그릿을 약화하는 표현</th>
      <th>성장형 사고방식과 그릿을 강화하는 표현</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“너는 타고났어! 마음에 든다”</td>
      <td>“열심히 배우는구나! 마음에 든다.”</td>
    </tr>
    <tr>
      <td>“적어도 노력은 했잖니!”</td>
      <td>“결과가 안 좋았네. 어떤 식으로 했는지. 어떻게 하면 나을지 이야기 해보자”</td>
    </tr>
    <tr>
      <td>“참 잘했어! 굉장한 재능이구나!”</td>
      <td>“참 잘햇어! 더 개선할 부분은 뭐가 있을까?!”</td>
    </tr>
    <tr>
      <td>“어려운 거야. 설령 못 하더라도 상실할 것 없어.”</td>
      <td>“어려운 거야. 아직 못 한다고 해서 상심할 것 없어.”</td>
    </tr>
    <tr>
      <td>“이건 네 강점이 아닌가 보다. 네가 기여할 다른 일이 있을 테니까 걱정하지마”</td>
      <td>“나는 목표 기준을 좀 높게 잡아. 같이 그 기준에 도달할 수 있도록 내가 이끌어 줄게.”</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>원포인트 레슨
    <ul>
      <li>절대 포기 하지 마라
        <ul>
          <li>마지막 한번더, 이번이 마지막 이다. 더더</li>
          <li>자신이 나아갈 방향, 끈기, 열정
            <ul>
              <li>SBS “재능의 함정” : 노력에 대한 칭찬이 필요하다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>(재능 + 역할(역할이 있는 노력)) =&gt; 강점</li>
      <li>강점 + 경험 =&gt; 그릿</li>
      <li>4가지 키워드
        <ul>
          <li>관심 : 미묘한 차이를 즐겨라</li>
          <li>연습 : 의식적인 연습, 정교한 연습</li>
          <li>목적 : 롤모델, 가치와 연관성</li>
          <li>희망 : 나은 내일을 만들겠다는 결심, SBS “작심 1만시간”</li>
        </ul>
      </li>
      <li>숙련 vs 역량
        <ul>
          <li>배추김치만 잘 담그는 숙력</li>
          <li>배추김치만 만들어 보았지만 파김치 갓김치도 금방 배울 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="section-3">*. 현장 메모 첨부</h4>
<ul>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3Y2NaZU9xY0hOUDA" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3S2ZuQTY2VVRqRnc" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3THRWQkRJZktVZ1E" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3THRWQkRJZktVZ1E" alt="" /></li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3VkF6ZHdKeGF6M00" alt="" /></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>클린아키텍처 듣기 전부터 고민하던 내용들</title>
	  <link>//whywhy</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-08T00:00:00+00:00</pubDate>
	  <guid>//whywhy</guid>
	  <description><![CDATA[
	     <h4 id="section">적용에 앞서 많은 고민중</h4>
<ul>
  <li>고민은 좋은거.</li>
</ul>

<h4 id="mvp-----">1. MVP등의 각종 패턴은 정말 만능일까? 의문점들</h4>
<ul>
  <li>장점은 매우 많습니다. 개발자가 많고 교육 시간이 많으면 하는게 좋습니다. 테스트하기에 좋다.</li>
  <li>의문점들
    <ul>
      <li>요즘 유행하는 MVP 패턴을 적용해 보려고 공부중 이지만 유지보수가 정말 편해 질까?</li>
      <li>MVP를 정말 열심히 해서 잘 적용하면 다른 사람들이 잘 알아 볼 수 있을까?</li>
      <li>만약 회사에 신입이 오면 코드가 잘 보고 비슷한 패턴으로 추가를 해줄까?</li>
      <li>정말 유지 보수가 쉬울까?</li>
    </ul>
  </li>
  <li>패턴을 적용하면 우선 많은 파일들이 생김
    <ul>
      <li>패키지 관리를 어떻게 해야 할까? ‘M’ 끼리 ‘V’ 끼리 ‘P’ 끼리</li>
      <li>액티비티는 뷰에 넣어야 하나?</li>
    </ul>
  </li>
  <li>패턴을 적용하면 거의 대부분이 DI라이브러를 추가하기 시작 함(dagger 등)
    <ul>
      <li>컴파일단계에서 추가되어서 기본 구조를 모르면 약간 많이 어색함</li>
      <li>스프링을 공부 했던 사람은 매우 편하다고 함</li>
      <li>C 를 기반으로 하는 저 같은 사람에게는 너무 어색함</li>
    </ul>
  </li>
  <li>지금 만드는 코드들을 보면 액티비티에 다 넣는다. 앱을 만들면서 아래 내용 말고는 없는거 같다. 앱 자체에 알고리즘이라고 할 만한 내용이 없다. 거의 모든일이 서버 의존적이다.
    <ul>
      <li>뷰 초기화(현재는 구글의 데이터 바인딩을 사용해서 안함)</li>
      <li>뷰 이벤트 등록</li>
      <li>http 리스너 등록</li>
    </ul>
  </li>
  <li>
    <p>서버개발자가 있어서 그럴수도 있지만 사내에 막강한 서버개발자가 있고 기본 구성이 서버1명 +앱1명 이라고 가정하고 앱을 만드는 경우를 가정하자. (매우 개인적인 생각들)</p>

    <ul>
      <li>회원 가입 시나리오 및 추가내용
        <ul>
          <li>앱 :  아이디 비밀번호를 서버에 전송</li>
          <li>서버 : 아이디 비밀번호 저장, 토큰 발급</li>
          <li>앱 : 토큰으로 API 접근</li>
          <li>간단하게 회원 가입가능하게 만들었다.</li>
          <li>사업팀에서 요청 사항이 생겼다.
            <ul>
              <li>카카오톡 회원 가입을 추가해 주세요.</li>
              <li>소셜로그인 기능도 결국 소셜의 아이디값을 콜백으로 받아서 이를 회원 가입 시나리오에 추가함, 비밀번호가 없음</li>
            </ul>
          </li>
          <li>매우 간단한 내용이고 다른일들이 발생해도 추가 하기 쉬운 일들이라고 생각한다.</li>
          <li>xml 에 아이디 비밀번호 입력란이 있고 회원 가입 버튼만 있으면 된다.</li>
          <li>카카오톡 버튼이 추가가 필요하면 카카오 sdk 호출이 하여 아이디를 받을수 있는 리스너를 등록한다.
            <ul>
              <li>성공 리스너에서 자사 회원 가입 API를 호출한다.</li>
            </ul>
          </li>
          <li>회원 가입을 시나리오를 가정해 보았고 추가되는 사항도 만들어 보았다.</li>
          <li>액티비티에 기본적인 클래스 분리와 함수 분리만 하였을때에도 변경 되는 로직에 큰무리 없이 쉽게 추가가 가능하다.</li>
          <li>MVP 패턴을 적용하려면 정확히 지킬건 지켜주고 싶다.
            <ul>
              <li>기존 포스트 내용들 처럼 액티비티에 뷰 와 프리젠터 파일 만들어 주고 액티비티와 연결해주고 각종 이벤트들을 연결해 준다.</li>
              <li>카카오 버튼이 하나 추가되어도 뷰와 프리젠터에 추가해서(어렵지는 않다.)</li>
              <li>카카오 SDK api를 이용해서 리스너 등록하고 결과를 처리하고</li>
              <li>프리젠터 임플리먼트에서 결과를 받아서 뷰 함수를 호출하여 화면 업데이트 하고 …</li>
            </ul>
          </li>
          <li>
            <p>위와 같은 상황이 거의 대부분 구성이었다. 앱에서 비지니스로직,모델 이라고 할 내용이 거의 없다.</p>
          </li>
          <li>통신 요청하고 결과를 화면에 보여준다. 이게 거의 대부분의 앱의 구성이었다.</li>
          <li>이렇다 보니 왜 mvp 를 써서 코드가 복잡해 보이게 하는지 잘 이해가 되지 않는다.</li>
          <li>유닛테스트를 만들기 쉽다.
            <ul>
              <li>위 내용중 유닛 테스트는 어떤게 있을까를 생각해 보자</li>
              <li>어떤게 나올까요 애매한 상황이라고 생각합니다.</li>
              <li>왜냐면 내용이 없습니다.</li>
              <li>그래도 뭔가 하고 싶어서..
                <ul>
                  <li>유닛테스트를 하는데 통신 API에 잘못된 값들만 넣어서 결과를 확인한다.
                    <ul>
                      <li>통신 테스트는 별개로 서버와 함께 하는게 좋을거 같은 생각, 내가 만든 기능테스트라고 하기에는 어려워 보임</li>
                    </ul>
                  </li>
                  <li>결과로 받은 내용이 화면에 나오는 부분을 확인한다.</li>
                </ul>
              </li>
              <li>mvp 패턴보다는 차라리 리액트개념을 넣어보자는게 나을거 같다.</li>
              <li>rx로만 앱을 구성하면 한눈에 보기좋고 수정들이 훨씬더 좋으니깐</li>
              <li>등등 하기싫은 이유들..</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>의문점이 생기는 이유는 하기 싫어서 핑계를 찾는거 같다.</li>
  <li>mvp 와 같은 패턴이 생기는 이유를 생각해 보았습니다.
    <ul>
      <li>UI 쪽과 그이외의 기능을 분리하고 UI와 기능의 연결을 단일 통로로 해결하자</li>
      <li>이게 핵심이라고 판단 하고 있습니다.</li>
      <li>mvc, mvvc, mvp 등등을 만들어서 패턴을 만들어 보는 이유는 조금더 규격화 해보는게 아닌지 생각합니다.</li>
      <li>여기서부터 또 다른의문점이 생기기 시작 했습니다.</li>
      <li>저렇게 화면에 보이는 부분만 따로 만들면 자바가 동작 하는 여러 플랫폼에서 동작 해야 하는거 아닐까?</li>
      <li>절대 안되죠 왜냐면 화면에 보이는 부분은 분리했지만 안드로이드 플랫폼 안에서 구분이니깐요</li>
      <li>그래서 이런 저런 생각하던중 클린아키텍처를 보고 기본부터 다시 생각하기 시작함</li>
      <li>드로이드나이츠의 클린아키텍처 세션을듣고 클린아키텍처 먼저 적용이 필요하다고 생각함</li>
    </ul>
  </li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>드로이드나이츠 클린아키텍처 세션</title>
	  <link>//clean-acrhitecture</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-04-08T00:00:00+00:00</pubDate>
	  <guid>//clean-acrhitecture</guid>
	  <description><![CDATA[
	     <h4 id="section">드로이드나이츠 클린아키텍처</h4>
<ul>
  <li>드로이드나이츠 컨퍼런스 참가후 작성한 글 입니다.</li>
  <li>
    <p>그중 기억에 남는 클린 아키텍처를 정리 하였습니다.</p>
  </li>
  <li>
    <p><a href="https://speakerdeck.com/sunghyunzz/clean-architecture-in-android/">참고 : https://speakerdeck.com/sunghyunzz/clean-architecture-in-android</a></p>
  </li>
  <li>
    <p><a href="https://realm.io/kr/news/clean-architecture-in-android//">참고 : https://realm.io/kr/news/clean-architecture-in-android/</a></p>
  </li>
  <li><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html">참고 : https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html</a></li>
</ul>

<h4 id="section-1">1. 변화에 잘 적응하는 아키텍처</h4>
<ul>
  <li>이전 까지 했던 고민이 이걸로 보입니다. 어떤 변화든 잘 적응하는 코드를 만들자</li>
  <li>적응을 잘하는건 변하는 부분만 수정하자 &lt;- 이 부분이 중요</li>
  <li>변화에 잘 대응할 수 있다.</li>
  <li>= 변화에 따른 코드의 변경이 적다.
    <ul>
      <li>테이블 구조를 변경했는데 액티비티를 변경???</li>
    </ul>
  </li>
  <li>= 코드가 잘 분리되어있다.
    <ul>
      <li>잘 분리되어야지 그냥 분리하면 안됨</li>
    </ul>
  </li>
  <li>= 코드가 본질에 맞게 설계되어있다.
    <ul>
      <li>어떻게 레이아웃을 구성할까에 사용할까를 이용하면 안됨</li>
      <li>본질
        <ul>
          <li>도메인의 본질 : 기획자, 디자이너가, 사용자가 받아들이는 형태 일반적으로 보여지는 형태가 바뀌는거지 기본 개념이 변경되지 않음. 가계부를 예로 들어서 소비내역, 지출내역이라는 개념은 변경되지 않는다. 변경되는 어떻게 보여줄지 어떻게 필터링 할지가 변경 되는 거다. 도메인의 본질의 개념을 이해햐자.</li>
          <li>개발구조상의 본질 : 쉐어드프리퍼런스, 렘, sqlite 가 있는데 각가의 사용을 언제든 변경 없이 사용이 가능해야한다!?. 쉐어드 프리퍼런스를 수정 했는데 액티비티 수정을 해야 하면 코드가 잘못 된거다.</li>
          <li>안드로이드 구조 상의 본질 : 안드로이드 라이프사이클등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="section-2">2. 기본 아키텍처</h4>
<ul>
  <li>엉클밥의 클린아키텍처 서버
    <ul>
      <li>
        <p><img src="https://drive.google.com/uc?id=0BwUadct9RzY3cmtQUjlkYlN5QTg" alt="" /></p>
      </li>
      <li>바깥쪽이 보여주는 부분</li>
      <li>가장안쪽이 개념단위
        <ul>
          <li>프레임워크 독립적
            <ul>
              <li>레트로핏 -&gt; 볼리 로 변경이 쉬움</li>
            </ul>
          </li>
          <li>테스트 가능</li>
          <li>ui 독립적</li>
          <li>db 독립적
            <ul>
              <li>서버에서 사용하던지, 내부에서 사용하던지 중요치 않음</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><img src="https://drive.google.com/uc?id=0BwUadct9RzY3YU9CMXN5S2FTRXc" alt="기본" />
    <ul>
      <li>안드로이드의 계층을 4개로 사용자에게 보여지는 로직과 관련된 Presentation 레이어</li>
      <li>DB, 네트워크를 포함한 데이터를 가져오는 Data 레이어</li>
      <li>사용자의 유스케이스로 분리되는 Domain 레이어
        <ul>
          <li>get트랜잭션</li>
        </ul>
      </li>
      <li>사용자의 개념을 정의하는 Entity 레이어</li>
      <li>이 네 레이어 간의 의존성은 위에서 아래로 발생해야 합니다. 즉, 가장 하단부의 레이어일 수록 가장 의존성이 낮아야 합니다. 가량 프리젠테이션 레이어는 데이터 레이어를 알지만 데이터는 프리젠테이션을 몰라야 하며, 이 덕분에 맨 아래의 엔티티는 순수한 Java 내지는 Kotlin 모듈이 될 수 있습니다. 이런 레이어의 분리 덕분에 본질을 정의할 때 어떤 데이터베이스에 저장될지, 어떤 뷰에서 보일지 고민하지 않고 Entity를 작성할 수 있고, 이에 대한 유스 케이스로 Domain 레이어를 작성할 수 있습니다. 또한 트랜잭션을 가져오는 것을 Data에서, 어떻게 보여줄 것인지를 Presentation에서 고민하면 됩니다.</li>
    </ul>
  </li>
</ul>

<h5 id="entity">2.1 Entity</h5>
<ul>
  <li>순수한 Java(Kotlin) 모듈</li>
  <li>Android와의 의존성이 없음
    <ul>
      <li>엔터티는 안드로이드의 파서러블을 사용할 수 없음</li>
    </ul>
  </li>
  <li>파서러블의 고민은 뷰 모델</li>
  <li>도메인(비즈니스 로직)에서 파생되는 개념을 표현</li>
  <li>(같은 서비스) Android - iOS - 서버 모두 동일한 형태</li>
  <li>아래가 샘플로 보여준 코틀린 코드 입니다. 자바는 코틀린은 모르지만 느낌상으로 같다고 만들어본 코드 입니다.</li>
  <li>가계부에서 소비내역 지출 내역의 변경되지 않는다.</li>
  <li>모든 내용이 엔터티에 포함되어 있다.</li>
  <li>TransactionType 엔터티로 선언한것이다.</li>
  <li>테이블간의 조인을 위해서 트랜잭션 아이디 등은 데이터베이스를 위함이기에 엔터티에서는넣으면 안됨</li>
  <li><code class="highlighter-rouge">kotlin
  class TransactionCategory( 
    val id: String, 
    val name: String, 
    val transactionType: TransactionType, 
    val priority: Int
  ) : Entity
</code></li>
  <li><code class="highlighter-rouge">java
  class TransactionCategory extends Entity( 
    String id; 
    String name;
    TransactionType transactionType;
    Int priority;
  ) : 
</code></li>
</ul>

<h5 id="domain">2.2 Domain</h5>
<ul>
  <li>순수한 Java(Kotlin) 모듈</li>
  <li>Android와의 의존성이 없음</li>
  <li>Use Case</li>
  <li>Repository Interface 정의</li>
  <li>예
    <ul>
      <li>뱅크레포지토리를 주입을 받고</li>
      <li>인터페이스정의만 함</li>
      <li>하는 액션은 getAll</li>
      <li>BanksRepository 는 인터페이스로 존재</li>
      <li>도메인 레이어에 존재</li>
      <li>유스케이스는 데이터베이스를 고려하지 말자</li>
      <li>사고의 흐름</li>
      <li>
        <p>```kotlin
class GetBanks(val repository: BanksRepository) : UseCase&lt;List<bank>&gt;(){ 
  override fun buildUseCaseObservable(): Observable&lt;List<bank>&gt; { 
    return repository.getAll() 
  } 
}</bank></bank></p>

        <p>interface BanksRepository : Repository {<br />
  fun getAll(): Observable&lt;List<bank>&gt; 
  fun update(bank: Bank): Completable 
}</bank></p>

        <p>```</p>
      </li>
    </ul>
  </li>
</ul>

<h5 id="data">2.3 data</h5>
<ul>
  <li>Repository의 실제 구현</li>
  <li>Data Source 의존성</li>
  <li>Android 의존성(어느순간 생기기 시작 가능성)</li>
  <li>데이터베이스 의존성이 생김</li>
  <li>도메인에서 정의한 인터페이스 구현이다. 렘 오브젝트를 엔터티로 변환 한다.</li>
  <li>렘이 sqlite로 변경되면 해당 레이어에서 처리 한다.</li>
  <li>똑같은 도메인의 유지하여 인테페이스를 네트워크로 변경가능하다.</li>
  <li>데이터모델은 렘이 아닌 응답값의 리스폰스로 변경하면 된다.</li>
  <li>예
    <ul>
      <li>
        <script src="https://gist.github.com/pyeongho/a621449874cd17a0c12041baf56fa835.js"></script>
      </li>
    </ul>
  </li>
</ul>

<h5 id="presentation">2.4 Presentation</h5>
<ul>
  <li>UI 레벨의 처리 (mvp, mvc)</li>
  <li>Android 의존성이 강함</li>
  <li>View와 Presenter</li>
  <li>함수 이름도 onViewCreated 처럼 각각의 행동에 맞게
    <ul>
      <li>onNextButtonClicked</li>
    </ul>
  </li>
  <li>내부 로직이 변경되어도 뷰 코드는 변겨이 안됨</li>
  <li>파서러블이 필요할때 프리젠터에서도 뷰 모델이 있고 엔터티를 매핑하여 사용한다.</li>
  <li>예
    <ul>
      <li>
        <script src="https://gist.github.com/pyeongho/618f625aa3f4a212f97197981ed5ea41.js"></script>
      </li>
      <li>
        <script src="https://gist.github.com/pyeongho/6b325023418e98ab2d0a496da91d4087.js"></script>
      </li>
    </ul>
  </li>
</ul>

<h4 id="section-3">3. 좋은 코드가 좋은 제품이다.</h4>
<ul>
  <li>각각의 레이어에서 모델이 존재해서 진입 장벽이 있지만 유지보수가 쉽다.</li>
</ul>

<h4 id="section-4">* 현장 메모</h4>
<ul>
  <li><img src="https://drive.google.com/uc?id=0BwUadct9RzY3cG41UmxfbEN4NjQ" alt="1페이지" /></li>
  <li><img src="https://drive.google.com/uc?id=0BwUadct9RzY3NTNGRVpKLXNSOTg" alt="2페이지" /></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>구글 드라이브를 이용해서 쉽게 이미지를 올리자</title>
	  <link>//google-drive-for-image</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-03-29T00:00:00+00:00</pubDate>
	  <guid>//google-drive-for-image</guid>
	  <description><![CDATA[
	     <h4 id="github-page---">맥에서 github page 이미지 쉽게 올리기</h4>
<ul>
  <li>깃허브 페이지를 이용중 가장 힘든건 스크린샷을 추가하는 방법이라 생각해서 찾아보니 구글드라이브를 이미지서버로 사용이 가능해서 적용해 보았습니다. 문제는 사파리에서 정상동작 안한다는 단점</li>
</ul>

<p><a href="https://beomi.github.io/2017/03/27/Use-GoogleDrive-as-Image-Server/">참고 : https://beomi.github.io/2017/03/27/Use-GoogleDrive-as-Image-Server/</a>
#### 1. 구글 드라이브 설치
  - homebrew 를 이용해서 쉽게 설치
  - $brew install gdrive
  - 설치 완료후
  - $gdrive list 
  - 입력하면 인증해야 한다고 나오면서 아래처럼 링크가 나옵니다.
    <code class="highlighter-rouge">
    Authentication needed
    Go to the following url in your browser:
    https://accounts.google.com/o/oauth2/auth?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx........
    Enter verification code:
   </code>
  - 권한 요청 페이지가 나오고 권한을 허용하면  인증 코드가 나온는데 복사 해서 입력란에 넣어 줍니다.
  - 다시 한번
  - $gdrive list
  - 자신의 구글드라이브의 루트의 리스트가 나옵니다.</p>

<h4 id="section">2. 캡쳐 쉘 스크립트 만들기</h4>
<ul>
  <li>
    <script src="https://gist.github.com/anonymous/1582cd1b8c6afd2fa682d71779e03aa9.js"></script>
  </li>
  <li>쉘 파일을 적당한 위치에 만든다.</li>
  <li>위 파일로 캡쳐하면 구글드라이브 루트에 생성되는 불편 함이 있습니다.</li>
  <li>p 옵션을 사용하면 원하는 폴더에 넣을수 있다고 하는데 폴더 이름을 적어도 잘 안됨</li>
  <li>문제는 옵션 다음에 적어할 내용은 폴더 위치의 ID 를 적어야 합니다.</li>
  <li>폴더 이름이 아닌 폴더 ID 입니다.</li>
  <li>폴더 ID는</li>
  <li>$gdrive list</li>
  <li>명령어를 입력하면 확인 할 수 있습니다.</li>
</ul>

<h4 id="gdrive--">3. 여기까지가 gdrive 공부정도 입니다</h4>
<ul>
  <li>아래 앱을 만들때는 스크립트를 복사 해서 사용하기웨 위 내용은 사용 안하더라구요</li>
</ul>

<h4 id="section-1">4. 맥용 앱을 만들어서 단축키로 실행해야죠</h4>
<ul>
  <li>Platypus 요런 프로그램이 쉘 스크립트를 앱으로 만들어 줍니다.</li>
  <li><a href="http://sveinbjorn.org/files/software/platypus.zip">다운로드 링크 : Platypus</a></li>
  <li>다운 받아서 실행하면 보안 어쩌고 저쩌고 하면서 실행이 안되면 설정 -&gt; 보안 항목에서 실행 할 수 있습니다.</li>
  <li>아래 이미지중 new 를 눌러서</li>
  <li>스크립트를 붙혀넣기 하였습니다.</li>
  <li>
    <script src="https://gist.github.com/pyeongho/1a1ba765dcd809de71d4a7bd029d9dc6.js"></script>
  </li>
  <li>코드는 크게 다르지 않지만 gdrive 가 절대 경로로 변경 된게 다릅니다.</li>
  <li>아래 처럼 인터페이스 및 필요없는 옵션 체크 해제 후 앱을 만들었습니다.</li>
  <li>앱 프로그램을 애플리케이션으로 이동하여 알프레드로 호출하니 잘 동작 합니다.</li>
  <li>어차피 단축키 추가해봐야 외우기 힘들테니 그냥 알프레드를 이용하려고 합니다.</li>
  <li><img src="http://drive.google.com/uc?export=view&amp;id=0BwUadct9RzY3MlJrOERUMG15ejA" alt="테스트" /></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>gitugb.io 지킬에 사진업로드 쉽게 하는 앱개발</title>
	  <link>//ios_git_client</link>
	  <author>PyeongHo</author>
	  <pubDate>2017-03-27T00:00:00+00:00</pubDate>
	  <guid>//ios_git_client</guid>
	  <description><![CDATA[
	     <h3 id="ios--githubio----">iOS 에서 github.io에 사진을 첨부한 글을 포스팅한다.</h3>
<ul>
  <li>스마튼폰에서 찍은 사진을 블로그에 바로 올리고 싶은 생각으로 앱을 개발해 보기로 결정</li>
</ul>

<h4 id="section">1. 공부할 자료 수집</h4>
<ul>
  <li>깃 라이브러리
    <ul>
      <li><a href="https://github.com/libgit2/objective-git#carthage">https://github.com/libgit2/objective-git#carthage</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/SwiftGit2/SwiftGit2">https://github.com/SwiftGit2/SwiftGit2</a></li>
  <li>carthage 사용법을 알아야 한다.
    - <a href="https://swifter.kr/2016/04/24/carthage-카르테지-설치-방법/">https://swifter.kr/2016/04/24/carthage-카르테지-설치-방법/</a></li>
</ul>

<p>####2. carthage 사용법 
  - homebrew로 설치 하기
     - 설치 안되어 있으면
       - $ ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”</p>

<ul>
  <li>$ brew update</li>
  <li>$ brew install carthage</li>
  <li>Cartfile 파일 생성하기
    <ul>
      <li>프로젝트 루트에 Cartfile 파일을 만들어서</li>
      <li>라이브러리 사용 설명서에 나온 주소를 입력 한다.</li>
      <li>정확한 문법은 인터넷에서 확인해 주세요</li>
      <li>예)  github “libgit2/objective-git”</li>
    </ul>
  </li>
  <li>프로젝트 루트에서 명령어 실행
    <ul>
      <li>$ carthage update</li>
    </ul>
  </li>
  <li>라이브러리에 따라서 헤더 위치를 추가 해야합니다.
    <ul>
      <li>프로젝트 세팅 -&gt; 빌드 세팅 -&gt; Header Search Path (all,level)</li>
    </ul>
  </li>
  <li>import ObjectiveGit 추가후 컴파일 완료</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
