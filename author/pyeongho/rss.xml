<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>pyeongho.github.io/</title>
   
   <link>https://pyeongho.github.io/</link>
   <description>즐거운 공장</description>
   <language>en-uk</language>
   <managingEditor> PyeongHo</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>앱 아이콘 동적 변경</title>
	  <link>//change-icon</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-11-06T00:00:00+00:00</pubDate>
	  <guid>//change-icon</guid>
	  <description><![CDATA[
	     <h3>아이콘을 동적 변경해야 하는일도 있는 세상</h3>

<ul>
<li>세상은 어떤일들이 일어 날지 모른다. 앱 아이콘을 조건에 따라 변경하고 싶어 하는 일도 있다.</li>
<li>정말 가능하다 ㅎㅎ</li>
</ul>

<h3>동적 아이콘 변경</h3>

<ul>
<li><a href="https://github.com/myinnos/AppIconNameChanger">AppIconNameChanger</a> </li>
<li>동작은 github 에 라이브러리가 잘 처리해 줍니다.</li>
</ul>

<h3>기본적인 알리아스 사용</h3>

<ul>
<li>애플리케이션 배포후에 런처 액티비티를 변경해야하는 일이 발생 할때 사용하면 좋다.</li>
<li>앱 업데이트로 바탕화면의 아이콘이 없어지는건 앱이 동작 안하는것과 같다.</li>
<li>아래 코드와 같이 기존 액티비티의 이름(기존 이름을 알리아스로 설정)이 실행되면 신규 액티비타를 실행 시켜 주는 방법 </li>
</ul>

<p><script src="https://gist.github.com/pyeongho/57ea15753697fd8c3e35a87d18e8fa64.js"></script></p>

<h3>동작 확인</h3>

<ul>
<li>메니페스트의 activity-alias 를 이용하는 방식이다.</li>
<li>알리아스의 번역처럼 별명을 지어 주는 내용입니다.</li>
<li>알리아스를 만들어서 각각의 속성을 주고 targetActivity 를 이용해서 실행 시킬 액티비티를 설정</li>
<li>동작해야 하는 액티비티는 하나가 되지만 각각의 별칭을 이용해서 접근이 가능하다.</li>
<li>기본동작 해양하는 알리아스를  android:enabled=&quot;true&quot; 활성화 하면 된다.</li>
<li>코드에서 해당 알리아스를 기본으로 동작 시켜 주면 된다.<br></li>
<li>아래 코드 내용처럼 패키지매니저를 이용해서 패키지 구성 요소를 변경 할수 있다.</li>
</ul>

<p><script src="https://gist.github.com/pyeongho/ce5b9f9862ab86312bd6203e2dd8648e.js"></script></p>

	  ]]></description>
	</item>

	<item>
	  <title>Jetpack 사용을 위한 기초 공부 AAC(ViewModel)</title>
	  <link>//aac_c2</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-10-29T00:00:00+00:00</pubDate>
	  <guid>//aac_c2</guid>
	  <description><![CDATA[
	     <h3>샘플은 구글</h3>

<ul>
<li><a href="https://github.com/googlesamples/android-sunflower">해바라기</a><br></li>
<li><a href="https://github.com/googlesamples/android-architecture-components">구글 샘플</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a></li>
</ul>

<h3>패턴의 변화</h3>

<ul>
<li>ViewModel클래스는 UI 관련 데이터를 라이프 사이클을 고려한 방식으로 저장하고 관리하도록 설계되었습니다. 이 ViewModel클래스를 사용하면 화면 회전과 같은 구성 변경시에도 데이터를 유지할 수 있습니다.</li>
</ul>

<h3>뷰모델</h3>

<ul>
<li>뷰모델은 옵저버패턴이라고 이해중</li>
<li>데이터가 변화 가능한곳에 콜백 같은 옵저버를 추가한다.</li>
<li>UI 쪽에서 해당 데이터의 콜백을 이용하여 업데이트 한다.</li>
<li>데이터를 콜백 형태로 묶어 놓기 때문에 위에서 말하는 UI 와 완전 분리가 가능하다.</li>
<li>예를 들어 특정 데이터가 변경 되면 콜백 발생하도록 하고 콜백에서 UI 업데이트를 처리한다.</li>
<li>이런 개념으로 이해 함</li>
<li>BasicRxJavaSampleKotlin 기본으로 공부 중</li>
<li>콜백을 넣어 주는 부분이 직접접이지 않아 이해 하고 있어야 이해가 된다.</li>
<li>아래와 같은 코드가 있을 때 Rx 를 이용해서  viewModel.userName()  변화를 감지하여 UI 업데이트 </li>
<li>클릭 이벤트에서 updateUserName() 를 호출 하면 DB 완료후 결과를 다시 읽어 UI 를 업데이트 함</li>
<li>하지만 뷰모엘을 이용하면 콜백으로 변경 내용을 확인 하므로 UI 업데이트에 대한 의존성을 없앨수 있다.</li>
</ul>
<div class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">      override fun onStart() {
            super.onStart()
            // Subscribe to the emissions of the user name from the view model.
            // Update the user name text view, at every onNext emission.
            // In case of error, log the exception.
            disposable.add(viewModel.userName()
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({ this.user_name.text = it },
                            { error -&gt; Log.e(TAG, "Unable to get username", error) }))
        }

        override fun onStop() {
            super.onStop()

            // clear all the subscription
            disposable.clear()
        }

        private fun updateUserName() {
            val userName = user_name_input.text.toString()
            // Disable the update button until the user name update has been done
            update_user_button.isEnabled = false
            // Subscribe to updating the user name.
            // Enable back the button once the user name has been updated
            disposable.add(viewModel.updateUserName(userName)
                    .subscribeOn(Schedulers.io())
                    .observeOn(AndroidSchedulers.mainThread())
                    .subscribe({ update_user_button.isEnabled = true },
                            { error -&gt; Log.e(TAG, "Unable to update username", error) }))
        }

</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>Jetpack 사용을 위한 기초 공부 AAC(Room)</title>
	  <link>//aac_c1</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-10-29T00:00:00+00:00</pubDate>
	  <guid>//aac_c1</guid>
	  <description><![CDATA[
	     <h3>샘플은 구글</h3>

<ul>
<li><a href="https://github.com/googlesamples/android-sunflower">해바라기</a><br></li>
<li><a href="https://github.com/googlesamples/android-architecture-components">구글 샘플</a></li>
<li><a href="https://developer.android.com/training/data-storage/room/defining-data">Room 엔터티</a></li>
<li><a href="https://www.bsidesoft.com/?p=6003">비사이드소프트</a><br></li>
</ul>

<h3>샘플 내용 요약</h3>

<ul>
<li>sunflower, 구글 AAC 샘플을 적용하기전 기초지식 부터</li>
<li>짧은 샘플이지만 기본적인 내용부터 알아야 가능 </li>
</ul>

<h3>라이브데이터</h3>

<ul>
<li>기존 데이터를 DB 에 넣어 오프라인에서도 기존데이터는 볼수 있도록 하자</li>
<li>항상 최신데이터가 필요 할 수도 있지만 예전 데이터라도 보고 싶을때가 있다. </li>
</ul>

<h3>기초 지식 1: ROOM</h3>

<ul>
<li>라이브 데이터를 사용하기 위해서 기초인 room<br></li>
<li>일반적인 DB 에서는 테이블을 만들어 사용하지만 room 은 orm 형태로 클래스를 만들어 사용한다.</li>
<li>아래와 같이 테이블을 만들어 사용 해야 한다.</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">    create table Items(
        id int NOT NULL,
        name varchar(255) NOT NULL,
        description varchar(255),
        price int,
        PRIMARY KEY (id)
    )
</code></pre></div>
<ul>
<li>Room 의 Entity 형태로 변경하면 아래와 같이 클래스 선언후 필요한 어노테이션을 추가하면 된다.</li>
<li>참고내용으로 실제 적용 할때는 찾아서 하는게 좋습니다.

<ul>
<li>어노테이션들

<ul>
<li>@Entity(primaryKeys = {“firstName”, “lastName”})  : 복합키 </li>
<li>@ColumnInfo(name = “first_name”)String firstName : 객체 필드명과 실제 테이블 필드명이 다를 때의 처리</li>
<li>@Ignore Bitmap picture : 무시할 객체의 필드</li>
<li>@Entity(indices = {@Index(“name”), @Index(value = {“last_name”, “address”})}) : 인덱스설정 </li>
<li>@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = “id”, childColumns = “user_id”)) : 외래키 설정 </li>
<li>@Embedded OtherEntity data : 중첩엔티티로 표현하기</li>
</ul></li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">    @Entity(tableName = "Items")
    data class ItemEntity(
        @PrimaryKey
        val id:Int,
        val name:String ,
        val description:String, 
        val price:Int
    )
</code></pre></div>
<h3>DAO : 쿼리 인터페이스</h3>

<ul>
<li>Room 전체 적인 DB 개념이니 데이터의 추가 삭제를 담당 하는 인터페이스</li>
<li>SQLite3 를 사용하기에 쿼리문을 직접 사용하거나 제공 되는 어노테이션을 사용하면 된다.</li>
<li>아래는 오너테이션 사용 관련 자바 입니다. 공부하는 코드가 자바라 </li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">  // 예제 1
  @Dao
  public interface MyDao {
      @Query("SELECT * FROM user")
      public User[] loadAllUsers();
  }

  // 예제 2
  @Dao
  public interface MyDao {
      @Delete
      public void deleteUsers(User... users);
  }

  // 예제 2
  @Dao
  public interface MyDao {
      @Update
      public void updateUsers(User... users);
  }

  // 예제 3 
  @Dao
  public interface MyDao {
      @Insert(onConflict = OnConflictStrategy.REPLACE)
      public void insertUsers(User... users);

      @Insert
      public void insertBothUsers(User user1, User user2);

      @Insert
      public void insertUsersAndFriends(User user, List&lt;User&gt; friends);
  }
</code></pre></div>
<h3>엔터티, DAO 를 이용한 데이터베이스 생성</h3>

<ul>
<li>빌더 패턴이 적용된 데이터 베이스</li>
<li>여기 까지는 기본적인 내용으로 실제 적용은 다른 포스트에서...</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">    @Database(entities = arrayOf(User::class), version = 1)
    abstract class UsersDatabase : RoomDatabase() {

        abstract fun userDao(): UserDao

        companion object {

            @Volatile private var INSTANCE: UsersDatabase? = null

            fun getInstance(context: Context): UsersDatabase =
                    INSTANCE ?: synchronized(this) {
                        INSTANCE ?: buildDatabase(context).also { INSTANCE = it }
                    }

            private fun buildDatabase(context: Context) =
                    Room.databaseBuilder(context.applicationContext,
                            UsersDatabase::class.java, "Sample.db")
                            .build()
        }
    }


</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>안드로이드 Jetpack 중 네비게이션 에디터 사용</title>
	  <link>//navigation-editor</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-07-03T00:00:00+00:00</pubDate>
	  <guid>//navigation-editor</guid>
	  <description><![CDATA[
	     <h3>안드로이드 Jetpack</h3>

<ul>
<li>가중 눈에 가는 네비게이션 에디터를 사용해 보려고 했지만 사용법은 금방 나오지만 어떻게 해야 에디터가 나오는지 안보인다.</li>
<li>File -&gt; Settings -&gt; Experimental -&gt; Enable Navigation Editor 을 활성화 하자<br></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>ConstraintLayout 이제 사용 할 듯</title>
	  <link>//constraint</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-07-03T00:00:00+00:00</pubDate>
	  <guid>//constraint</guid>
	  <description><![CDATA[
	     <h3>출처</h3>

<ul>
<li><a href="https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html">구글 블로그 원문</a></li>
<li><a href="http://abandonia.tistory.com/1">구글 블로그 번역문</a></li>
</ul>

<h3>주저리</h3>

<ul>
<li>언제 부턴가 새로운 앱을 만들면  ConstraintLayout 으로 hello world 나왔음에도 불구 하고   RelativeLayout 과 LinearLayout 를 이용하여 디자인을 구성 하였다. 잘 사용 하고 있는데 또 나와서 공부 하기 귀찮아서 ㅎㅎㅎ</li>
</ul>

<h3>성능 이슈</h3>

<ul>
<li> ConstraintLayout 이걸 사용 하면 많은 이야기가 있지만 일단 기존 방법 보다 빠르다고 한다. 트리구조의 뷰를 찾아서 계산 하는게 아니라 1 depth 구조로  만드는게 핵심 처럼 보인다. 수평적인 계층 구조라고 한다. 그리고 실제 테스트 했을때 빨라 졌다고 합니다.</li>
<li><p>테스트 소스</p>

<ul>
<li><a href="https://github.com/googlesamples/android-constraint-layout-performance">테스트 샘플코드 깃허브</a></li>
</ul></li>
<li><h3>애니메이션</h3></li>
<li><p>구글에서 제공하는 샘플이 있어서 공부도 할겸 다운 받아서 공부</p>

<ul>
<li><a href="https://github.com/googlesamples/android-ConstraintLayoutExamples">구글 샘플 깃허브</a></li>
</ul></li>
<li><p>레이아웃도 레이아웃 이지만 MotionLayout 이용한 샘플이 사용 할 수 밖에 없는 이유를 제공 했습니다. </p></li>
<li><p>일단 부드러운 애니메이션이 있으니 무조건 사용하기로 결심   </p></li>
</ul>

<h3>문제점</h3>

<ul>
<li>tool 에서 제공해주는 ConstraintLayout 컨버팅 기능을 사용하려고 했지만 레이아웃이 죄다 깨지는 현상이 발생 했습니다.</li>
<li>역시 한땀 한땀 공부 하며 바꿔야 겠습니다.</li>
</ul>

<h3>현재까지 팁</h3>

<ul>
<li>마법사 지팡이를 잘 누르자 </li>
<li>정렬 기능은 너무 좋은것(마치 포토샵의 정릴 기능 처럼)</li>
<li>팩 기능, 여러가지를 묶어서 사용 할때 좋아요</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>푸시 내용 업데이트</title>
	  <link>//push2</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-05-24T00:00:00+00:00</pubDate>
	  <guid>//push2</guid>
	  <description><![CDATA[
	     <h3>푸시 적용</h3>

<ul>
<li><a href="https://pyeongho.github.io/push">https://pyeongho.github.io/push</a></li>
<li><p>위 글에서 푸시 관련 내용을 작성 하였습니다.</p></li>
<li><p>좀더 명확 하게 하기 위한 내용입니다.</p></li>
<li><p>푸시 발송 json 내용에 notification 있으면 백그라운드 앱에서는 os 가 처리합니다.</p></li>
<li><p>기존 처럼 직접 노티피케이션을 만들어서 사용 하고 싶을때는 꼭  notification 내용을 제거 하고 data 만 보내서 원하는 형태로 사용하면 됩니다. </p>

<ul>
<li>이미지를 노티피케이션을 만들거나 </li>
<li>확장 되는 이미지를 만들거나<br></li>
</ul></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>방법을 생각해 보자</title>
	  <link>//thinks</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-03-16T00:00:00+00:00</pubDate>
	  <guid>//thinks</guid>
	  <description><![CDATA[
	     <h4>1. 안드로이드 보안을 위한 방법들</h4>

<ul>
<li>중요한 정보를 저장 하거나 하드코딩 안하면 되지만 어쩔수 없다면</li>
<li><p>아래 내용들은 최대한 지저분하게 여기 저기 막 넣어 둔다.</p></li>
<li><p>인증서를 확인 한다.</p>

<ul>
<li>자바와 네이티브 양쪽</li>
<li>자바 코드는 많으니 네이티브 코드만 추후에 라이브러리를 만들어 볼 생각 입니다.
<script src="https://gist.github.com/pyeongho/a67c34db9cfb06ff1162ec834919b4fb.js"></script></li>
</ul></li>
<li><p>루팅 차단</p></li>
<li><p>설치 프로그램을 확인한다.</p>

<ul>
<li>플레이스토어 설치 인지, 아마존 설치 인지</li>
<li>java, c 둘다 추가 해야 한다.</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">private static final String PLAY_STORE_APP_ID = "com.android.vending";
public static boolean verifyInstaller(final Context context) {

    final String installer = context.getPackageManager()
            .getInstallerPackageName(context.getPackageName());
    return installer != null
            &amp;&amp; installer.startsWith(PLAY_STORE_APP_ID);

}
</code></pre></div></li>
<li><p>에뮬레이터 동작을 차단 한다.</p>

<ul>
<li>에뮬레이터에서 동작 하면 보안에 더욱 취약 하다.</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">public static boolean checkEmulator() {
    try {
        boolean goldfish = getSystemProperty("ro.hardware").contains("goldfish");
        boolean emu = getSystemProperty("ro.kernel.qemu").length() &gt; 0;
        boolean sdk = getSystemProperty("ro.product.model").equals("sdk");
        if (emu || goldfish || sdk) {
            return true;
        }
    } catch (Exception e) {
    }
    return false;
}
</code></pre></div></li>
<li><p>ndk 통신을 이용한 구글 파이어베이스 서버로 통신</p>

<ul>
<li>base.apk md5 비교</li>
</ul></li>
<li><p>덱스 로더 활용    </p>

<ul>
<li><a href="https://github.com/Instagram/ig-lazy-module-loader">https://github.com/Instagram/ig-lazy-module-loader</a></li>
</ul></li>
<li><p>구 버전 jdgui 버그 코드 추가</p>

<ul>
<li>아래 코드를 추가하면 인터널 에러 발생 </li>
<li>코틀린의 경우 companion object 이 있으면 해당 객체 안에 넣어야합니다. </li>
<li><a href="http://www.programering.com/q/MTMyQDMwATc.html">http://www.programering.com/q/MTMyQDMwATc.html</a></li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">wJ</span> <span class="o">=</span> <span class="s">"0123456789abcdef"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">imsi</span> <span class="o">=</span> <span class="s">"204046330839890"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"0"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">keyword</span> <span class="o">=</span> <span class="s">"Telephone"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">tranlateKeyword</span> <span class="o">=</span> <span class="s">"%E7%94%B5%E8%AF%9D"</span><span class="o">;</span>
</code></pre></div></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>윈도우즈에서 파이어베이스 CLI 에러</title>
	  <link>//firebase_cli_error</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-03-08T00:00:00+00:00</pubDate>
	  <guid>//firebase_cli_error</guid>
	  <description><![CDATA[
	     <h3>윈도우즈에서 파이어베이스를 이용해서 개발중 발생한 버그</h3>

<ul>
<li>기본적인 파이어베이스 CLI 사용법 아닙니다.</li>
</ul>

<h4>firebase deploy 진행중 발생하는 에러</h4>
<div class="highlight"><pre><code class="language-" data-lang="">    i  deploying functions, hosting
    Running command: npm --prefix $RESOURCE_DIR run lint
    npm ERR! path D:\abcd\$RESOURCE_DIR\package.json
    npm ERR! code ENOENT
    npm ERR! errno -4058
    npm ERR! syscall open
    npm ERR! enoent ENOENT: no such file or directory, open 'D:\abcd\$RESOURCE_D
    IR\package.json'
    npm ERR! enoent This is related to npm not being able to find a file.
    npm ERR! enoent
    ...
</code></pre></div>
<ul>
<li>윈도우에서 최종 배포 명령을 하니 위처럼 에러가 발생 여기 저기 찾아 보니 수정을 해야함 

<ul>
<li>$RESOURCE<em>DIR -&gt; %RESOURCE</em>DIR%</li>
<li>윈도우와 리눅스계열 컴퓨터의 경로 설정 방법에 의한 차이로 보입니다. </li>
<li>firebase.json 파일을 열어서 위 내용처럼 바꾸어 주면 됩니다.</li>
</ul></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>코틀린 KTX</title>
	  <link>//kotlin_ktx</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-03-05T00:00:00+00:00</pubDate>
	  <guid>//kotlin_ktx</guid>
	  <description><![CDATA[
	     <h3>코틀린 개발용 확장 라이브러리 KTX 에대한 지극히 개인적인 생각</h3>

<ul>
<li><p>코틀린 KTX 내용 블로그</p>

<ul>
<li><a href="https://android-developers.googleblog.com/2018/02/introducing-android-ktx-even-sweeter.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+blogspot%2FhsDu+%28Android+Developers+Blog%29">KTX 안드로이드 구글 블로그 영문</a></li>
<li><a href="https://developers-kr.googleblog.com/2018/02/introducing-android-ktx-even-sweeter-kotlin-development-for-android.html">KTX 안드로이드 구글 블로그 번역리뷰</a></li>
<li>샘플만 사용해 본 느낌 이고 현재 개발 환경으로 인해서 생각한 내용 입니다. 한줄로 나온 부분은 잘 확인해 보셔야 합니다. </li>
</ul></li>
</ul>

<p>| kotlin | kotlin with KTX |
| ---- | ---- |
|val uri = Uri.parse(myUriString) | val uri = myUriString.toUri() |
|sharedPreferences.edit().putBoolean(key, value).apply() | sharedPreferences.edit { putBoolean(key, value) } |</p>

<ul>
<li>위 내용 이외에 많은 부분이 있습니다.</li>
<li>기존 코틀린 또는 람다 표기법보다 코드 양이 더욱 줄어 들고 어떤 코드는 직관적 입니다.( =&gt; toUri())</li>
<li>하지만 이런 내용들은 API를 코틀린의 기능을 이용해서 확장 시킨 기능이어서 새롭게 시작 개발자 들에게 좋지 못하다고 생각합니다.(교육을 못하는 개발환경)</li>
<li>toUri() 를 사용할때 기본적인 함수를 모를때 발생 할 수 있는 일들, sharedPreferences apply 를 사용 안 할 가능성등 많은 부분이 초급 개발자들이 사용 하면 추후 발생 할 내용 들이 부담 스럽게 다가 옵니다. </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>프로가드라 알차게 사용하기</title>
	  <link>//pro_guard</link>
	  <author>PyeongHo</author>
	  <pubDate>2018-03-02T00:00:00+00:00</pubDate>
	  <guid>//pro_guard</guid>
	  <description><![CDATA[
	     <h4>1. 코드난독화를 위해서 사용하는 프로가드</h4>

<ul>
<li>자세한 프로가드 사용법은 아닙니다.</li>
<li>패키지 구성을 어떻게 하면 좋을지에 대한 내용입니다.</li>
<li>프로가드 적용시 패키명과 클래스명이 유지 되는것중 액티비티가 있습니다.</li>
<li>그렇게 되면 기본적인 구성을 확인 가능하면 그 안에 있는 하위 패키지 이름을 보면서 내용 유추가 가능해 진다.</li>
<li>아주 간단한 방법으로 액티비티를 따로 모아서 패키지를 만들어서 관리혀면 생각보다 좋다.</li>
<li>액티비티 뿐만 아니라 클래스명과 패키지명이 유지되어야 하는 내용을 따로 관리하면 생각보다 큰 효과를 얻습니다.</li>
<li><p><a href="https://academy.realm.io/kr/posts/jon-reeve-reverse-engineering-is-not-just-for-hackers-android/">https://academy.realm.io/kr/posts/jon-reeve-reverse-engineering-is-not-just-for-hackers-android/</a></p></li>
<li><p>보안의 명언 </p>

<ul>
<li>&quot;정말 보안이 필요한 것이 있다면 앱에 넣지 마세요.&quot;</li>
<li>앱을 완벽하게 보호할 수는 없습니다. 투입할 수 있는 시간의 양과 보안 정도와 공격자 수 사이에 절충해야 합니다</li>
</ul></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
